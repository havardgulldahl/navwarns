<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>NavWarns Map (North Pole Projection)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: calc(100% - 80px);
        }

        #timeline-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.15);
            padding: 12px 20px;
            z-index: 1000;
        }

        #timeline-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 8px;
        }

        #timeline-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            min-width: 120px;
        }

        #date-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #e0e0e0 0%, #4a90e2 50%, #2ecc71 100%);
            outline: none;
            -webkit-appearance: none;
        }

        #date-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #4a90e2;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        #date-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #4a90e2;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        #date-display {
            font-size: 15px;
            color: #2c3e50;
            min-width: 180px;
            text-align: right;
            font-weight: 500;
        }

        .timeline-button {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            background: #4a90e2;
            color: white;
            font-size: 13px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .timeline-button:hover {
            background: #357abd;
        }

        .timeline-button.active {
            background: #2ecc71;
        }

        #quick-dates {
            display: flex;
            gap: 8px;
        }

        .quick-date-btn {
            padding: 4px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-date-btn:hover {
            background: #f0f0f0;
            border-color: #4a90e2;
        }

        .popup-content {
            max-width: 260px;
            word-wrap: break-word;
        }

        .popup-content h3 {
            margin: 0 0 4px 0;
            font-size: 14px;
        }

        .popup-content .meta {
            font-size: 11px;
            color: #555;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .popup-content pre {
            white-space: pre-wrap;
            font-family: system-ui, sans-serif;
            font-size: 12px;
            margin: 0;
            background: #f7f7f7;
            padding: 6px;
            border-radius: 4px;
            max-height: 240px;
            overflow-y: auto;
        }

        .legend {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 10px;
            line-height: 1.3;
            color: #222;
            font-size: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            max-width: 260px;
        }

        .legend h4 {
            margin: 0 0 4px 0;
            font-size: 13px;
        }

        .legend .item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 2px 0;
        }

        .legend .swatch {
            width: 14px;
            height: 14px;
            border: 1px solid #555;
            border-radius: 3px;
            flex: 0 0 auto;
        }

        .inline-badge {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            background: #eee;
            font-size: 10px;
            margin-right: 4px;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <div id="timeline-container">
        <div id="timeline-controls">
            <span id="timeline-label">View NavWarns as of:</span>
            <input type="range" id="date-slider" min="0" max="100" value="100" step="1">
            <span id="date-display">Today (Current)</span>
        </div>
        <div id="quick-dates">
            <button class="quick-date-btn" onclick="setQuickDate(-7)">7 days ago</button>
            <button class="quick-date-btn" onclick="setQuickDate(-14)">2 weeks ago</button>
            <button class="quick-date-btn" onclick="setQuickDate(-30)">1 month ago</button>
            <button class="quick-date-btn" onclick="setQuickDate(-90)">3 months ago</button>
            <button class="timeline-button active" onclick="setQuickDate(0)">Show Current Only</button>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <!-- Projection libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>

    <script>
        // EPSG:3575 (Arctic Polar Stereographic)
        const crs3575 = new L.Proj.CRS(
            'EPSG:3575',
            //'+proj=stere +lat_0=90 +lat_ts=71 +lon_0=0 +k=1 +datum=WGS84 +units=m +no_defs',
            '+proj=laea +lat_0=90 +lon_0=10 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs',
            {
                origin: [-4889334.802955, 4889334.802955], // top-left
                bounds: L.bounds(
                    [-4889334.802955, -4889334.802955],
                    [4889334.802955, 4889334.802955]
                ),
                resolutions: [
                    38197.928, 19098.964, 9549.482, 4774.741,
                    2387.370, 1193.685, 596.843, 298.422,
                    149.211, 74.606, 37.303
                ]
            }
        );

        const map = L.map('map', {
            crs: crs3575,
            center: [89.9, 0],
            zoom: 2,
            minZoom: 0,
            maxZoom: 10
        });

        // WMTS as REST template. For this service, TileMatrix = z (0..10), origin is top-left, so y is standard.
        const ArcticSDILayer = L.TileLayer.extend({
            getTileUrl: function (coords) {
                const z = coords.z;
                const x = coords.x;
                const y = coords.y;
                // WMTS REST template: /wmts/1.0.0/{layer}/{style}/{tilematrixset}/{TileMatrix}/{TileRow}/{TileCol}.{formatExt}
                return `https://basemap.arctic-sdi.org/mapcache/wmts/1.0.0/arctic_cascading/default/3575/${z}/${y}/${x}.png`;
            }
        });

        const arcticBasemap = new ArcticSDILayer('', {
            tileSize: 256,
            attribution: '<a href="https://arctic-sdi.org/">Arctic SDI</a>'
        }).addTo(map);

        L.control.layers({ 'Arctic SDI (EPSG:3575)': arcticBasemap }, {}).addTo(map);

        // Timeline filtering state
        let currentFilterDate = new Date(); // Default to today
        let allNavwarnsData = null;
        let mainFeatureGroup = null;

        // Parse cancellation date from "THIS MSG DDHHMMZ MON YY" or "THIS MSG DDHHMM UTC MON YY" format
        function parseCancellationDate(cancelStr) {
            if (!cancelStr) return null;

            // Match patterns like "THIS MSG 171600 UTC SEP 25" or "THIS MSG 171600Z SEP 25"
            const match = cancelStr.match(/THIS (?:MSG|MESSAGE) (\d{2})(\d{2})(\d{2})(?:Z| UTC) ([A-Z]{3}) (\d{2})/);
            if (match) {
                const [, day, hour, minute, monthStr, year] = match;
                const monthMap = {
                    'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,
                    'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11
                };
                const month = monthMap[monthStr];
                if (month === undefined) return null;

                const fullYear = 2000 + parseInt(year);
                return new Date(Date.UTC(fullYear, month, parseInt(day), parseInt(hour), parseInt(minute)));
            }
            return null;
        }

        // Check if a navwarn is valid at a given date
        function isNavwarnValidAt(feature, checkDate) {
            const properties = feature.properties || {};
            const cancellations = properties.cancellations || [];

            // Check if navwarn has started (using DTG as start date)
            const dtg = properties.dtg;
            if (dtg) {
                // Parse DTG - handle ISO format with or without timezone info
                // Check if string already has timezone: Z suffix, or +/- after T (not in date part)
                let hasTimezone = dtg.endsWith('Z');
                if (!hasTimezone && dtg.includes('T')) {
                    const timePart = dtg.split('T')[1];
                    hasTimezone = timePart.includes('+') || timePart.includes('-');
                }
                const dtgWithTz = hasTimezone ? dtg : dtg + 'Z';
                const startDate = new Date(dtgWithTz);
                if (!isNaN(startDate.getTime()) && checkDate < startDate) {
                    return false; // This navwarn hasn't started yet
                }
            } else {
                // For navwarns without DTG (like Russian NAVAREA XX), use year as heuristic
                // Assume they start at the beginning of their year (in UTC)
                const year = properties.year;
                if (year) {
                    const yearStart = new Date(Date.UTC(year, 0, 1)); // January 1st of the year in UTC
                    if (checkDate < yearStart) {
                        return false; // Before this navwarn's year
                    }
                }
            }

            // Check for self-cancellation with date (end date)
            for (const cancel of cancellations) {
                if (cancel && (cancel.includes('THIS MSG') || cancel.includes('THIS MESSAGE'))) {
                    const cancelDate = parseCancellationDate(cancel);
                    if (cancelDate && checkDate > cancelDate) {
                        return false; // This navwarn is cancelled
                    }
                }
            }
            return true; // Valid at this date
        }

        // Filter features based on current date
        function filterFeaturesByDate(features, date) {
            return features.filter(f => isNavwarnValidAt(f, date));
        }

        // Colors and formatting
        const categoryColors = {
            military: '#d73027',
            accident: '#4575b4',
            navigation: '#fc8d59',
            cable: '#8c510a',
            other: '#1a9850',
            default: '#6a3d9a'
        };
        function getCategoryColor(c) { return categoryColors[c] || categoryColors.default; }

        function formatDate(dtg) {
            if (!dtg) return '';
            try {
                const d = new Date(dtg + (dtg.endsWith('Z') ? '' : 'Z'));
                if (isNaN(d)) return dtg;
                return d.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, 'Z');
            } catch { return dtg; }
        }

        function buildPopup(feature) {
            const p = feature.properties || {};
            const body = (p.body || '').trim();
            const hazard = p.hazard_type || 'N/A';
            const category = p.category || 'N/A';
            const title = p.title || p.msg_id || 'NavWarn';
            const cancellations = (p.cancellations || []).filter(Boolean);
            const color = getCategoryColor(category);
            return `
        <div class="popup-content">
          <h3>${title}</h3>
          <div class="meta">
            <span class="inline-badge">${hazard}</span>
            <span class="inline-badge" style="background:${color};color:#fff;">${category}</span><br/>
            <strong>DTG:</strong> ${formatDate(p.dtg)}<br/>
            <strong>Raw DTG:</strong> ${p.raw_dtg || ''}
            ${cancellations.length ? `<br/><strong>Cancel:</strong> ${cancellations.join('; ')}` : ''}
          </div>
          <pre>${body.replace(/</g, '&lt;')}</pre>
        </div>`;
        }

        // Render features on the map
        function renderFeatures(features, featureGroup) {
            featureGroup.clearLayers();

            const filteredData = {
                type: 'FeatureCollection',
                features: features
            };

            const layer = L.geoJSON(filteredData, {
                pointToLayer: (feature, latlng) => {
                    const category = feature.properties?.category;
                    const color = getCategoryColor(category);
                    return L.circleMarker(latlng, {
                        radius: 6,
                        fillColor: color,
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.85
                    });
                },
                onEachFeature: (feature, layer) => {
                    layer.bindPopup(() => buildPopup(feature));

                    if (feature.geometry && feature.geometry.type === 'MultiPoint') {
                        const latlngs = feature.geometry.coordinates
                            .map(c => L.latLng(c[1], c[0]))
                            .filter(ll => Number.isFinite(ll.lat) && Number.isFinite(ll.lng));
                        if (latlngs.length >= 2) {
                            const category = feature.properties?.category;
                            const color = getCategoryColor(category);
                            L.polyline(latlngs, {
                                color,
                                weight: 2,
                                opacity: 0.6,
                                dashArray: '4,4'
                            }).addTo(featureGroup);
                        }
                    }
                }
            }).addTo(featureGroup);
        }

        // Update map based on current filter date
        function updateMapDisplay() {
            if (!allNavwarnsData || !mainFeatureGroup) return;

            const filteredFeatures = filterFeaturesByDate(allNavwarnsData.features, currentFilterDate);
            renderFeatures(filteredFeatures, mainFeatureGroup);

            // Update count in legend if it exists
            updateLegendCount(filteredFeatures.length, allNavwarnsData.features.length);
        }

        // Load GeoJSON in WGS84; DO NOT override coordsToLatLng. Leaflet will project to CRS.
        function loadGeoJsonLayer(url, { fit = false, addLegendFlag = false } = {}) {
            return fetch(url)
                .then(r => {
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
                    return r.json();
                })
                .then(data => {
                    allNavwarnsData = data;
                    mainFeatureGroup = L.featureGroup().addTo(map);

                    // Filter and render based on current date
                    const filteredFeatures = filterFeaturesByDate(data.features, currentFilterDate);
                    renderFeatures(filteredFeatures, mainFeatureGroup);

                    if (fit) {
                        const b = mainFeatureGroup.getBounds();
                        if (b.isValid()) map.fitBounds(b, { maxZoom: 4, padding: [20, 20] });
                    }
                    if (addLegendFlag) addLegend(data.features || []);
                    return { data, featureGroup: mainFeatureGroup };
                })
                .catch(err => {
                    console.error(`Failed to load ${url}:`, err);
                });
        }

        // Initial load
        loadGeoJsonLayer('navwarns.geojson', { fit: true, addLegendFlag: true });

        // Legend
        function addLegend(features) {
            // Always show the main categories in order
            const mainCategories = ['military', 'accident', 'navigation', 'cable', 'other'];

            // Collect any additional categories from the data
            const additionalCategories = new Set();
            features.forEach(f => {
                const cat = f.properties?.category;
                if (cat && !mainCategories.includes(cat)) {
                    additionalCategories.add(cat);
                }
            });

            // Combine main categories with any additional ones
            const categoryList = [...mainCategories, ...Array.from(additionalCategories).sort()];

            fetch('scrape_timestamp.txt')
                .then(r => r.ok ? r.text() : '')
                .catch(() => '')
                .then(tsRaw => {
                    const ts = (tsRaw || '').trim();
                    const legend = L.control({ position: 'bottomleft' });
                    legend.onAdd = function () {
                        const div = L.DomUtil.create('div', 'legend');
                        const fetchedLine = ts ? `<div class="fetched" style="font-size:10px;margin:2px 0 6px;">Fetched ${ts}</div>` : '';
                        div.innerHTML =
                            '<h4>NavWarns for the Arctic</h4>' + fetchedLine +
                            '<div id="navwarn-count" style="font-size:11px;margin:4px 0;color:#666;"></div>' +
                            categoryList.map(c => {
                                const col = getCategoryColor(c);
                                return `<div class="item"><span class="swatch" style="background:${col}"></span><span>${c}</span></div>`;
                            }).join('') +
                            '<hr style="margin:6px 0;" />' +
                            '<div style="font-size:10px; line-height:1.2;">' +
                            'Load layer for year: <input list="years" id="yearInput" placeholder="YYYY" style="width:6em;" /></div>' +
                            '<div style="margin-top:6px;font-size:10px;"><a href="navwarns.geojson" download target="_blank">Download GeoJSON</a></div>';
                        return div;
                    };
                    legend.addTo(map);

                    // Initialize count display
                    if (allNavwarnsData) {
                        const filtered = filterFeaturesByDate(allNavwarnsData.features, currentFilterDate);
                        updateLegendCount(filtered.length, allNavwarnsData.features.length);
                    }

                    setTimeout(() => {
                        const yearInput = document.getElementById('yearInput');
                        if (!yearInput) return;
                        const load = () => {
                            const y = (yearInput.value || '').trim();
                            if (!/^20\d{2}$/.test(y)) return;
                            loadArchiveYear(y);
                        };
                        yearInput.addEventListener('change', load);
                        yearInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') load(); });
                    }, 0);
                });
        }

        // Archive loader
        let archiveLayerGroup = null;
        function loadArchiveYear(year) {
            const url = `archive${year}.geojson`;
            if (archiveLayerGroup) {
                map.removeLayer(archiveLayerGroup);
                archiveLayerGroup = null;
            }
            // Note: Archive loading doesn't use the date filter
            fetch(url)
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (!data) return;
                    archiveLayerGroup = L.featureGroup().addTo(map);
                    renderFeatures(data.features || [], archiveLayerGroup);
                    const b = archiveLayerGroup.getBounds();
                    if (b.isValid()) map.fitBounds(b, { maxZoom: 4, padding: [20, 20] });
                })
                .catch(err => console.error('Failed to load archive:', err));
        }

        // Update legend count display
        function updateLegendCount(showing, total) {
            const countEl = document.getElementById('navwarn-count');
            if (countEl) {
                if (showing === total) {
                    countEl.innerHTML = `Showing all <strong>${total}</strong> NavWarns`;
                } else {
                    countEl.innerHTML = `Showing <strong>${showing}</strong> of ${total} NavWarns`;
                }
            }
        }

        // Timeline controls
        const dateSlider = document.getElementById('date-slider');
        const dateDisplay = document.getElementById('date-display');

        // Calculate date range (6 months back from today)
        const today = new Date();
        const sixMonthsAgo = new Date(today);
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

        // Helper to format date
        function formatDisplayDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Update date from slider
        dateSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);

            // Map slider (0-100) to date range
            const totalMs = today - sixMonthsAgo;
            const dateMs = sixMonthsAgo.getTime() + (totalMs * sliderValue / 100);
            currentFilterDate = new Date(dateMs);

            // Update display
            if (sliderValue === 100) {
                dateDisplay.textContent = 'Today (Current)';
            } else {
                dateDisplay.textContent = formatDisplayDate(currentFilterDate);
            }

            // Update map
            updateMapDisplay();
        });

        // Quick date buttons
        function setQuickDate(daysOffset) {
            const targetDate = new Date();
            targetDate.setDate(targetDate.getDate() + daysOffset);
            currentFilterDate = targetDate;

            // Update slider position
            const totalMs = today - sixMonthsAgo;
            const offsetMs = targetDate - sixMonthsAgo;
            const sliderPos = Math.max(0, Math.min(100, (offsetMs / totalMs) * 100));
            dateSlider.value = sliderPos;

            // Update display
            if (daysOffset === 0) {
                dateDisplay.textContent = 'Today (Current)';
                // Highlight the "Show Current Only" button
                document.querySelectorAll('.quick-date-btn, .timeline-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
            } else {
                dateDisplay.textContent = formatDisplayDate(currentFilterDate);
            }

            // Update map
            updateMapDisplay();
        }

        // Make setQuickDate available globally
        window.setQuickDate = setQuickDate;
    </script>

    <datalist id="years">
        <option value="2010">
        <option value="2011">
        <option value="2012">
        <option value="2013">
        <option value="2014">
        <option value="2015">
        <option value="2016">
        <option value="2017">
        <option value="2018">
        <option value="2019">
        <option value="2020">
        <option value="2021">
        <option value="2022">
        <option value="2023">
    </datalist>
</body>

</html>